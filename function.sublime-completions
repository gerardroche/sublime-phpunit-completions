{
    // scope:
    //
    // source.php
    //   blacklist:
    //     comment
    //     constant.other.class
    //     entity
    //     meta.catch
    //     meta.class
    //     meta.function.arguments
    //     meta.function.parameters
    //     meta.use
    //     string
    //     support.class
    //     variable.other
    //     variable.parameter
    //     meta.function.return-type
    // source.php meta.class.php meta.block.php meta.function.php meta.block.php
    //   blacklist:
    //     comment
    //     constant.other.class
    //     entity
    //     meta.catch
    //     meta.function.arguments
    //     meta.function.parameters
    //     meta.use
    //     string
    //     support.class
    //     variable.other
    //     variable.parameter
    //     meta.function.return-type

    "scope": "source.php - comment - constant.other.class - entity - meta.catch - meta.class - meta.function.arguments - meta.function.parameters - meta.use - string - support.class - variable.other - variable.parameter - meta.function.return-type, source.php meta.class.php meta.block.php meta.function.php meta.block.php - comment - constant.other.class - entity - meta.catch - meta.function.arguments - meta.function.parameters - meta.use - string - support.class - variable.other - variable.parameter - meta.function.return-type",
    "completions": [
        {"trigger":"any","contents":"\\$this->any();","kind":"function","annotation":"any(): PHPUnit\\Framework\\MockObject\\Rule\\AnyInvokedCount","details":"any(): PHPUnit\\Framework\\MockObject\\Rule\\AnyInvokedCount"},
        {"trigger":"anything","contents":"\\$this->anything();","kind":"function","annotation":"anything(): PHPUnit\\Framework\\Constraint\\IsAnything","details":"anything(): PHPUnit\\Framework\\Constraint\\IsAnything"},
        {"trigger":"arrayHasKey","contents":"\\$this->arrayHasKey(${1:string|int:key});","kind":"function","annotation":"arrayHasKey(string|int $key): PHPUnit\\Framework\\Constraint\\ArrayHasKey","details":"arrayHasKey(string|int $key): PHPUnit\\Framework\\Constraint\\ArrayHasKey"},
        {"trigger":"assertArrayHasKey","contents":"\\$this->assertArrayHasKey(${1:string|int:key}, ${2:ArrayAccess|array:array});","kind":"function","annotation":"assertArrayHasKey(string|int $key, ArrayAccess|array $array): void","details":"assertArrayHasKey(string|int $key, ArrayAccess|array $array): void"},
        {"trigger":"assertArrayNotHasKey","contents":"\\$this->assertArrayNotHasKey(${1:string|int:key}, ${2:ArrayAccess|array:array});","kind":"function","annotation":"assertArrayNotHasKey(string|int $key, ArrayAccess|array $array): void","details":"assertArrayNotHasKey(string|int $key, ArrayAccess|array $array): void"},
        {"trigger":"assertContains","contents":"\\$this->assertContains(${1:mixed:needle}, ${2:iterable:haystack});","kind":"function","annotation":"assertContains(mixed $needle, iterable $haystack): void","details":"assertContains(mixed $needle, iterable $haystack): void"},
        {"trigger":"assertContainsEquals","contents":"\\$this->assertContainsEquals(${1:mixed:needle}, ${2:iterable:haystack});","kind":"function","annotation":"assertContainsEquals(mixed $needle, iterable $haystack): void","details":"assertContainsEquals(mixed $needle, iterable $haystack): void"},
        {"trigger":"assertContainsOnly","contents":"\\$this->assertContainsOnly(${1:string:type}, ${2:iterable:haystack});","kind":"function","annotation":"assertContainsOnly(string $type, iterable $haystack): void","details":"assertContainsOnly(string $type, iterable $haystack): void"},
        {"trigger":"assertContainsOnlyInstancesOf","contents":"\\$this->assertContainsOnlyInstancesOf(${1:string:className}, ${2:iterable:haystack});","kind":"function","annotation":"assertContainsOnlyInstancesOf(string $className, iterable $haystack): void","details":"assertContainsOnlyInstancesOf(string $className, iterable $haystack): void"},
        {"trigger":"assertCount","contents":"\\$this->assertCount(${1:int:expectedCount}, ${2:Countable|Traversable|array:haystack});","kind":"function","annotation":"assertCount(int $expectedCount, Countable|Traversable|array $haystack): void","details":"assertCount(int $expectedCount, Countable|Traversable|array $haystack): void"},
        {"trigger":"assertDirectoryDoesNotExist","contents":"\\$this->assertDirectoryDoesNotExist(${1:string:directory});","kind":"function","annotation":"assertDirectoryDoesNotExist(string $directory): void","details":"assertDirectoryDoesNotExist(string $directory): void"},
        {"trigger":"assertDirectoryExists","contents":"\\$this->assertDirectoryExists(${1:string:directory});","kind":"function","annotation":"assertDirectoryExists(string $directory): void","details":"assertDirectoryExists(string $directory): void"},
        {"trigger":"assertDirectoryIsNotReadable","contents":"\\$this->assertDirectoryIsNotReadable(${1:string:directory});","kind":"function","annotation":"assertDirectoryIsNotReadable(string $directory): void","details":"assertDirectoryIsNotReadable(string $directory): void"},
        {"trigger":"assertDirectoryIsNotWritable","contents":"\\$this->assertDirectoryIsNotWritable(${1:string:directory});","kind":"function","annotation":"assertDirectoryIsNotWritable(string $directory): void","details":"assertDirectoryIsNotWritable(string $directory): void"},
        {"trigger":"assertDirectoryIsReadable","contents":"\\$this->assertDirectoryIsReadable(${1:string:directory});","kind":"function","annotation":"assertDirectoryIsReadable(string $directory): void","details":"assertDirectoryIsReadable(string $directory): void"},
        {"trigger":"assertDirectoryIsWritable","contents":"\\$this->assertDirectoryIsWritable(${1:string:directory});","kind":"function","annotation":"assertDirectoryIsWritable(string $directory): void","details":"assertDirectoryIsWritable(string $directory): void"},
        {"trigger":"assertDoesNotMatchRegularExpression","contents":"\\$this->assertDoesNotMatchRegularExpression(${1:string:pattern}, ${2:string:string});","kind":"function","annotation":"assertDoesNotMatchRegularExpression(string $pattern, string $string): void","details":"assertDoesNotMatchRegularExpression(string $pattern, string $string): void"},
        {"trigger":"assertEmpty","contents":"\\$this->assertEmpty(${1:mixed:actual});","kind":"function","annotation":"assertEmpty(mixed $actual): void","details":"assertEmpty(mixed $actual): void"},
        {"trigger":"assertEquals","contents":"\\$this->assertEquals(${1:mixed:expected}, ${2:mixed:actual});","kind":"function","annotation":"assertEquals(mixed $expected, mixed $actual): void","details":"assertEquals(mixed $expected, mixed $actual): void"},
        {"trigger":"assertEqualsCanonicalizing","contents":"\\$this->assertEqualsCanonicalizing(${1:mixed:expected}, ${2:mixed:actual});","kind":"function","annotation":"assertEqualsCanonicalizing(mixed $expected, mixed $actual): void","details":"assertEqualsCanonicalizing(mixed $expected, mixed $actual): void"},
        {"trigger":"assertEqualsIgnoringCase","contents":"\\$this->assertEqualsIgnoringCase(${1:mixed:expected}, ${2:mixed:actual});","kind":"function","annotation":"assertEqualsIgnoringCase(mixed $expected, mixed $actual): void","details":"assertEqualsIgnoringCase(mixed $expected, mixed $actual): void"},
        {"trigger":"assertEqualsWithDelta","contents":"\\$this->assertEqualsWithDelta(${1:mixed:expected}, ${2:mixed:actual}, ${3:float:delta});","kind":"function","annotation":"assertEqualsWithDelta(mixed $expected, mixed $actual, float $delta): void","details":"assertEqualsWithDelta(mixed $expected, mixed $actual, float $delta): void"},
        {"trigger":"assertFalse","contents":"\\$this->assertFalse(${1:mixed:condition});","kind":"function","annotation":"assertFalse(mixed $condition): void","details":"assertFalse(mixed $condition): void"},
        {"trigger":"assertFileDoesNotExist","contents":"\\$this->assertFileDoesNotExist(${1:string:filename});","kind":"function","annotation":"assertFileDoesNotExist(string $filename): void","details":"assertFileDoesNotExist(string $filename): void"},
        {"trigger":"assertFileEquals","contents":"\\$this->assertFileEquals(${1:string:expected}, ${2:string:actual});","kind":"function","annotation":"assertFileEquals(string $expected, string $actual): void","details":"assertFileEquals(string $expected, string $actual): void"},
        {"trigger":"assertFileEqualsCanonicalizing","contents":"\\$this->assertFileEqualsCanonicalizing(${1:string:expected}, ${2:string:actual});","kind":"function","annotation":"assertFileEqualsCanonicalizing(string $expected, string $actual): void","details":"assertFileEqualsCanonicalizing(string $expected, string $actual): void"},
        {"trigger":"assertFileEqualsIgnoringCase","contents":"\\$this->assertFileEqualsIgnoringCase(${1:string:expected}, ${2:string:actual});","kind":"function","annotation":"assertFileEqualsIgnoringCase(string $expected, string $actual): void","details":"assertFileEqualsIgnoringCase(string $expected, string $actual): void"},
        {"trigger":"assertFileExists","contents":"\\$this->assertFileExists(${1:string:filename});","kind":"function","annotation":"assertFileExists(string $filename): void","details":"assertFileExists(string $filename): void"},
        {"trigger":"assertFileIsNotReadable","contents":"\\$this->assertFileIsNotReadable(${1:string:file});","kind":"function","annotation":"assertFileIsNotReadable(string $file): void","details":"assertFileIsNotReadable(string $file): void"},
        {"trigger":"assertFileIsNotWritable","contents":"\\$this->assertFileIsNotWritable(${1:string:file});","kind":"function","annotation":"assertFileIsNotWritable(string $file): void","details":"assertFileIsNotWritable(string $file): void"},
        {"trigger":"assertFileIsReadable","contents":"\\$this->assertFileIsReadable(${1:string:file});","kind":"function","annotation":"assertFileIsReadable(string $file): void","details":"assertFileIsReadable(string $file): void"},
        {"trigger":"assertFileIsWritable","contents":"\\$this->assertFileIsWritable(${1:string:file});","kind":"function","annotation":"assertFileIsWritable(string $file): void","details":"assertFileIsWritable(string $file): void"},
        {"trigger":"assertFileNotEquals","contents":"\\$this->assertFileNotEquals(${1:string:expected}, ${2:string:actual});","kind":"function","annotation":"assertFileNotEquals(string $expected, string $actual): void","details":"assertFileNotEquals(string $expected, string $actual): void"},
        {"trigger":"assertFileNotEqualsCanonicalizing","contents":"\\$this->assertFileNotEqualsCanonicalizing(${1:string:expected}, ${2:string:actual});","kind":"function","annotation":"assertFileNotEqualsCanonicalizing(string $expected, string $actual): void","details":"assertFileNotEqualsCanonicalizing(string $expected, string $actual): void"},
        {"trigger":"assertFileNotEqualsIgnoringCase","contents":"\\$this->assertFileNotEqualsIgnoringCase(${1:string:expected}, ${2:string:actual});","kind":"function","annotation":"assertFileNotEqualsIgnoringCase(string $expected, string $actual): void","details":"assertFileNotEqualsIgnoringCase(string $expected, string $actual): void"},
        {"trigger":"assertFinite","contents":"\\$this->assertFinite(${1:mixed:actual});","kind":"function","annotation":"assertFinite(mixed $actual): void","details":"assertFinite(mixed $actual): void"},
        {"trigger":"assertGreaterThan","contents":"\\$this->assertGreaterThan(${1:mixed:expected}, ${2:mixed:actual});","kind":"function","annotation":"assertGreaterThan(mixed $expected, mixed $actual): void","details":"assertGreaterThan(mixed $expected, mixed $actual): void"},
        {"trigger":"assertGreaterThanOrEqual","contents":"\\$this->assertGreaterThanOrEqual(${1:mixed:expected}, ${2:mixed:actual});","kind":"function","annotation":"assertGreaterThanOrEqual(mixed $expected, mixed $actual): void","details":"assertGreaterThanOrEqual(mixed $expected, mixed $actual): void"},
        {"trigger":"assertInfinite","contents":"\\$this->assertInfinite(${1:mixed:actual});","kind":"function","annotation":"assertInfinite(mixed $actual): void","details":"assertInfinite(mixed $actual): void"},
        {"trigger":"assertInstanceOf","contents":"\\$this->assertInstanceOf(${1:string:expected}, ${2:mixed:actual});","kind":"function","annotation":"assertInstanceOf(string $expected, mixed $actual): void","details":"assertInstanceOf(string $expected, mixed $actual): void"},
        {"trigger":"assertIsArray","contents":"\\$this->assertIsArray(${1:mixed:actual});","kind":"function","annotation":"assertIsArray(mixed $actual): void","details":"assertIsArray(mixed $actual): void"},
        {"trigger":"assertIsBool","contents":"\\$this->assertIsBool(${1:mixed:actual});","kind":"function","annotation":"assertIsBool(mixed $actual): void","details":"assertIsBool(mixed $actual): void"},
        {"trigger":"assertIsCallable","contents":"\\$this->assertIsCallable(${1:mixed:actual});","kind":"function","annotation":"assertIsCallable(mixed $actual): void","details":"assertIsCallable(mixed $actual): void"},
        {"trigger":"assertIsClosedResource","contents":"\\$this->assertIsClosedResource(${1:mixed:actual});","kind":"function","annotation":"assertIsClosedResource(mixed $actual): void","details":"assertIsClosedResource(mixed $actual): void"},
        {"trigger":"assertIsFloat","contents":"\\$this->assertIsFloat(${1:mixed:actual});","kind":"function","annotation":"assertIsFloat(mixed $actual): void","details":"assertIsFloat(mixed $actual): void"},
        {"trigger":"assertIsInt","contents":"\\$this->assertIsInt(${1:mixed:actual});","kind":"function","annotation":"assertIsInt(mixed $actual): void","details":"assertIsInt(mixed $actual): void"},
        {"trigger":"assertIsIterable","contents":"\\$this->assertIsIterable(${1:mixed:actual});","kind":"function","annotation":"assertIsIterable(mixed $actual): void","details":"assertIsIterable(mixed $actual): void"},
        {"trigger":"assertIsList","contents":"\\$this->assertIsList(${1:mixed:array});","kind":"function","annotation":"assertIsList(mixed $array): void","details":"assertIsList(mixed $array): void"},
        {"trigger":"assertIsNotArray","contents":"\\$this->assertIsNotArray(${1:mixed:actual});","kind":"function","annotation":"assertIsNotArray(mixed $actual): void","details":"assertIsNotArray(mixed $actual): void"},
        {"trigger":"assertIsNotBool","contents":"\\$this->assertIsNotBool(${1:mixed:actual});","kind":"function","annotation":"assertIsNotBool(mixed $actual): void","details":"assertIsNotBool(mixed $actual): void"},
        {"trigger":"assertIsNotCallable","contents":"\\$this->assertIsNotCallable(${1:mixed:actual});","kind":"function","annotation":"assertIsNotCallable(mixed $actual): void","details":"assertIsNotCallable(mixed $actual): void"},
        {"trigger":"assertIsNotClosedResource","contents":"\\$this->assertIsNotClosedResource(${1:mixed:actual});","kind":"function","annotation":"assertIsNotClosedResource(mixed $actual): void","details":"assertIsNotClosedResource(mixed $actual): void"},
        {"trigger":"assertIsNotFloat","contents":"\\$this->assertIsNotFloat(${1:mixed:actual});","kind":"function","annotation":"assertIsNotFloat(mixed $actual): void","details":"assertIsNotFloat(mixed $actual): void"},
        {"trigger":"assertIsNotInt","contents":"\\$this->assertIsNotInt(${1:mixed:actual});","kind":"function","annotation":"assertIsNotInt(mixed $actual): void","details":"assertIsNotInt(mixed $actual): void"},
        {"trigger":"assertIsNotIterable","contents":"\\$this->assertIsNotIterable(${1:mixed:actual});","kind":"function","annotation":"assertIsNotIterable(mixed $actual): void","details":"assertIsNotIterable(mixed $actual): void"},
        {"trigger":"assertIsNotNumeric","contents":"\\$this->assertIsNotNumeric(${1:mixed:actual});","kind":"function","annotation":"assertIsNotNumeric(mixed $actual): void","details":"assertIsNotNumeric(mixed $actual): void"},
        {"trigger":"assertIsNotObject","contents":"\\$this->assertIsNotObject(${1:mixed:actual});","kind":"function","annotation":"assertIsNotObject(mixed $actual): void","details":"assertIsNotObject(mixed $actual): void"},
        {"trigger":"assertIsNotReadable","contents":"\\$this->assertIsNotReadable(${1:string:filename});","kind":"function","annotation":"assertIsNotReadable(string $filename): void","details":"assertIsNotReadable(string $filename): void"},
        {"trigger":"assertIsNotResource","contents":"\\$this->assertIsNotResource(${1:mixed:actual});","kind":"function","annotation":"assertIsNotResource(mixed $actual): void","details":"assertIsNotResource(mixed $actual): void"},
        {"trigger":"assertIsNotScalar","contents":"\\$this->assertIsNotScalar(${1:mixed:actual});","kind":"function","annotation":"assertIsNotScalar(mixed $actual): void","details":"assertIsNotScalar(mixed $actual): void"},
        {"trigger":"assertIsNotString","contents":"\\$this->assertIsNotString(${1:mixed:actual});","kind":"function","annotation":"assertIsNotString(mixed $actual): void","details":"assertIsNotString(mixed $actual): void"},
        {"trigger":"assertIsNotWritable","contents":"\\$this->assertIsNotWritable(${1:string:filename});","kind":"function","annotation":"assertIsNotWritable(string $filename): void","details":"assertIsNotWritable(string $filename): void"},
        {"trigger":"assertIsNumeric","contents":"\\$this->assertIsNumeric(${1:mixed:actual});","kind":"function","annotation":"assertIsNumeric(mixed $actual): void","details":"assertIsNumeric(mixed $actual): void"},
        {"trigger":"assertIsObject","contents":"\\$this->assertIsObject(${1:mixed:actual});","kind":"function","annotation":"assertIsObject(mixed $actual): void","details":"assertIsObject(mixed $actual): void"},
        {"trigger":"assertIsReadable","contents":"\\$this->assertIsReadable(${1:string:filename});","kind":"function","annotation":"assertIsReadable(string $filename): void","details":"assertIsReadable(string $filename): void"},
        {"trigger":"assertIsResource","contents":"\\$this->assertIsResource(${1:mixed:actual});","kind":"function","annotation":"assertIsResource(mixed $actual): void","details":"assertIsResource(mixed $actual): void"},
        {"trigger":"assertIsScalar","contents":"\\$this->assertIsScalar(${1:mixed:actual});","kind":"function","annotation":"assertIsScalar(mixed $actual): void","details":"assertIsScalar(mixed $actual): void"},
        {"trigger":"assertIsString","contents":"\\$this->assertIsString(${1:mixed:actual});","kind":"function","annotation":"assertIsString(mixed $actual): void","details":"assertIsString(mixed $actual): void"},
        {"trigger":"assertIsWritable","contents":"\\$this->assertIsWritable(${1:string:filename});","kind":"function","annotation":"assertIsWritable(string $filename): void","details":"assertIsWritable(string $filename): void"},
        {"trigger":"assertJson","contents":"\\$this->assertJson(${1:string:actual});","kind":"function","annotation":"assertJson(string $actual): void","details":"assertJson(string $actual): void"},
        {"trigger":"assertJsonFileEqualsJsonFile","contents":"\\$this->assertJsonFileEqualsJsonFile(${1:string:expectedFile}, ${2:string:actualFile});","kind":"function","annotation":"assertJsonFileEqualsJsonFile(string $expectedFile, string $actualFile): void","details":"assertJsonFileEqualsJsonFile(string $expectedFile, string $actualFile): void"},
        {"trigger":"assertJsonFileNotEqualsJsonFile","contents":"\\$this->assertJsonFileNotEqualsJsonFile(${1:string:expectedFile}, ${2:string:actualFile});","kind":"function","annotation":"assertJsonFileNotEqualsJsonFile(string $expectedFile, string $actualFile): void","details":"assertJsonFileNotEqualsJsonFile(string $expectedFile, string $actualFile): void"},
        {"trigger":"assertJsonStringEqualsJsonFile","contents":"\\$this->assertJsonStringEqualsJsonFile(${1:string:expectedFile}, ${2:string:actualJson});","kind":"function","annotation":"assertJsonStringEqualsJsonFile(string $expectedFile, string $actualJson): void","details":"assertJsonStringEqualsJsonFile(string $expectedFile, string $actualJson): void"},
        {"trigger":"assertJsonStringEqualsJsonString","contents":"\\$this->assertJsonStringEqualsJsonString(${1:string:expectedJson}, ${2:string:actualJson});","kind":"function","annotation":"assertJsonStringEqualsJsonString(string $expectedJson, string $actualJson): void","details":"assertJsonStringEqualsJsonString(string $expectedJson, string $actualJson): void"},
        {"trigger":"assertJsonStringNotEqualsJsonFile","contents":"\\$this->assertJsonStringNotEqualsJsonFile(${1:string:expectedFile}, ${2:string:actualJson});","kind":"function","annotation":"assertJsonStringNotEqualsJsonFile(string $expectedFile, string $actualJson): void","details":"assertJsonStringNotEqualsJsonFile(string $expectedFile, string $actualJson): void"},
        {"trigger":"assertJsonStringNotEqualsJsonString","contents":"\\$this->assertJsonStringNotEqualsJsonString(${1:string:expectedJson}, ${2:string:actualJson});","kind":"function","annotation":"assertJsonStringNotEqualsJsonString(string $expectedJson, string $actualJson): void","details":"assertJsonStringNotEqualsJsonString(string $expectedJson, string $actualJson): void"},
        {"trigger":"assertLessThan","contents":"\\$this->assertLessThan(${1:mixed:expected}, ${2:mixed:actual});","kind":"function","annotation":"assertLessThan(mixed $expected, mixed $actual): void","details":"assertLessThan(mixed $expected, mixed $actual): void"},
        {"trigger":"assertLessThanOrEqual","contents":"\\$this->assertLessThanOrEqual(${1:mixed:expected}, ${2:mixed:actual});","kind":"function","annotation":"assertLessThanOrEqual(mixed $expected, mixed $actual): void","details":"assertLessThanOrEqual(mixed $expected, mixed $actual): void"},
        {"trigger":"assertMatchesRegularExpression","contents":"\\$this->assertMatchesRegularExpression(${1:string:pattern}, ${2:string:string});","kind":"function","annotation":"assertMatchesRegularExpression(string $pattern, string $string): void","details":"assertMatchesRegularExpression(string $pattern, string $string): void"},
        {"trigger":"assertNan","contents":"\\$this->assertNan(${1:mixed:actual});","kind":"function","annotation":"assertNan(mixed $actual): void","details":"assertNan(mixed $actual): void"},
        {"trigger":"assertNotContains","contents":"\\$this->assertNotContains(${1:mixed:needle}, ${2:iterable:haystack});","kind":"function","annotation":"assertNotContains(mixed $needle, iterable $haystack): void","details":"assertNotContains(mixed $needle, iterable $haystack): void"},
        {"trigger":"assertNotContainsEquals","contents":"\\$this->assertNotContainsEquals(${1:mixed:needle}, ${2:iterable:haystack});","kind":"function","annotation":"assertNotContainsEquals(mixed $needle, iterable $haystack): void","details":"assertNotContainsEquals(mixed $needle, iterable $haystack): void"},
        {"trigger":"assertNotContainsOnly","contents":"\\$this->assertNotContainsOnly(${1:string:type}, ${2:iterable:haystack});","kind":"function","annotation":"assertNotContainsOnly(string $type, iterable $haystack): void","details":"assertNotContainsOnly(string $type, iterable $haystack): void"},
        {"trigger":"assertNotCount","contents":"\\$this->assertNotCount(${1:int:expectedCount}, ${2:Countable|Traversable|array:haystack});","kind":"function","annotation":"assertNotCount(int $expectedCount, Countable|Traversable|array $haystack): void","details":"assertNotCount(int $expectedCount, Countable|Traversable|array $haystack): void"},
        {"trigger":"assertNotEmpty","contents":"\\$this->assertNotEmpty(${1:mixed:actual});","kind":"function","annotation":"assertNotEmpty(mixed $actual): void","details":"assertNotEmpty(mixed $actual): void"},
        {"trigger":"assertNotEquals","contents":"\\$this->assertNotEquals(${1:mixed:expected}, ${2:mixed:actual});","kind":"function","annotation":"assertNotEquals(mixed $expected, mixed $actual): void","details":"assertNotEquals(mixed $expected, mixed $actual): void"},
        {"trigger":"assertNotEqualsCanonicalizing","contents":"\\$this->assertNotEqualsCanonicalizing(${1:mixed:expected}, ${2:mixed:actual});","kind":"function","annotation":"assertNotEqualsCanonicalizing(mixed $expected, mixed $actual): void","details":"assertNotEqualsCanonicalizing(mixed $expected, mixed $actual): void"},
        {"trigger":"assertNotEqualsIgnoringCase","contents":"\\$this->assertNotEqualsIgnoringCase(${1:mixed:expected}, ${2:mixed:actual});","kind":"function","annotation":"assertNotEqualsIgnoringCase(mixed $expected, mixed $actual): void","details":"assertNotEqualsIgnoringCase(mixed $expected, mixed $actual): void"},
        {"trigger":"assertNotEqualsWithDelta","contents":"\\$this->assertNotEqualsWithDelta(${1:mixed:expected}, ${2:mixed:actual}, ${3:float:delta});","kind":"function","annotation":"assertNotEqualsWithDelta(mixed $expected, mixed $actual, float $delta): void","details":"assertNotEqualsWithDelta(mixed $expected, mixed $actual, float $delta): void"},
        {"trigger":"assertNotFalse","contents":"\\$this->assertNotFalse(${1:mixed:condition});","kind":"function","annotation":"assertNotFalse(mixed $condition): void","details":"assertNotFalse(mixed $condition): void"},
        {"trigger":"assertNotInstanceOf","contents":"\\$this->assertNotInstanceOf(${1:string:expected}, ${2:mixed:actual});","kind":"function","annotation":"assertNotInstanceOf(string $expected, mixed $actual): void","details":"assertNotInstanceOf(string $expected, mixed $actual): void"},
        {"trigger":"assertNotNull","contents":"\\$this->assertNotNull(${1:mixed:actual});","kind":"function","annotation":"assertNotNull(mixed $actual): void","details":"assertNotNull(mixed $actual): void"},
        {"trigger":"assertNotSame","contents":"\\$this->assertNotSame(${1:mixed:expected}, ${2:mixed:actual});","kind":"function","annotation":"assertNotSame(mixed $expected, mixed $actual): void","details":"assertNotSame(mixed $expected, mixed $actual): void"},
        {"trigger":"assertNotSameSize","contents":"\\$this->assertNotSameSize(${1:Countable|Traversable|array:expected}, ${2:Countable|Traversable|array:actual});","kind":"function","annotation":"assertNotSameSize(Countable|Traversable|array $expected, Countable|Traversable|array $actual): void","details":"assertNotSameSize(Countable|Traversable|array $expected, Countable|Traversable|array $actual): void"},
        {"trigger":"assertNotTrue","contents":"\\$this->assertNotTrue(${1:mixed:condition});","kind":"function","annotation":"assertNotTrue(mixed $condition): void","details":"assertNotTrue(mixed $condition): void"},
        {"trigger":"assertNull","contents":"\\$this->assertNull(${1:mixed:actual});","kind":"function","annotation":"assertNull(mixed $actual): void","details":"assertNull(mixed $actual): void"},
        {"trigger":"assertObjectEquals","contents":"\\$this->assertObjectEquals(${1:object:expected}, ${2:object:actual});","kind":"function","annotation":"assertObjectEquals(object $expected, object $actual): void","details":"assertObjectEquals(object $expected, object $actual): void"},
        {"trigger":"assertObjectHasProperty","contents":"\\$this->assertObjectHasProperty(${1:string:propertyName}, ${2:object:object});","kind":"function","annotation":"assertObjectHasProperty(string $propertyName, object $object): void","details":"assertObjectHasProperty(string $propertyName, object $object): void"},
        {"trigger":"assertObjectNotHasProperty","contents":"\\$this->assertObjectNotHasProperty(${1:string:propertyName}, ${2:object:object});","kind":"function","annotation":"assertObjectNotHasProperty(string $propertyName, object $object): void","details":"assertObjectNotHasProperty(string $propertyName, object $object): void"},
        {"trigger":"assertSame","contents":"\\$this->assertSame(${1:mixed:expected}, ${2:mixed:actual});","kind":"function","annotation":"assertSame(mixed $expected, mixed $actual): void","details":"assertSame(mixed $expected, mixed $actual): void"},
        {"trigger":"assertSameSize","contents":"\\$this->assertSameSize(${1:Countable|Traversable|array:expected}, ${2:Countable|Traversable|array:actual});","kind":"function","annotation":"assertSameSize(Countable|Traversable|array $expected, Countable|Traversable|array $actual): void","details":"assertSameSize(Countable|Traversable|array $expected, Countable|Traversable|array $actual): void"},
        {"trigger":"assertStringContainsString","contents":"\\$this->assertStringContainsString(${1:string:needle}, ${2:string:haystack});","kind":"function","annotation":"assertStringContainsString(string $needle, string $haystack): void","details":"assertStringContainsString(string $needle, string $haystack): void"},
        {"trigger":"assertStringContainsStringIgnoringCase","contents":"\\$this->assertStringContainsStringIgnoringCase(${1:string:needle}, ${2:string:haystack});","kind":"function","annotation":"assertStringContainsStringIgnoringCase(string $needle, string $haystack): void","details":"assertStringContainsStringIgnoringCase(string $needle, string $haystack): void"},
        {"trigger":"assertStringContainsStringIgnoringLineEndings","contents":"\\$this->assertStringContainsStringIgnoringLineEndings(${1:string:needle}, ${2:string:haystack});","kind":"function","annotation":"assertStringContainsStringIgnoringLineEndings(string $needle, string $haystack): void","details":"assertStringContainsStringIgnoringLineEndings(string $needle, string $haystack): void"},
        {"trigger":"assertStringEndsNotWith","contents":"\\$this->assertStringEndsNotWith(${1:string:suffix}, ${2:string:string});","kind":"function","annotation":"assertStringEndsNotWith(string $suffix, string $string): void","details":"assertStringEndsNotWith(string $suffix, string $string): void"},
        {"trigger":"assertStringEndsWith","contents":"\\$this->assertStringEndsWith(${1:string:suffix}, ${2:string:string});","kind":"function","annotation":"assertStringEndsWith(string $suffix, string $string): void","details":"assertStringEndsWith(string $suffix, string $string): void"},
        {"trigger":"assertStringEqualsFile","contents":"\\$this->assertStringEqualsFile(${1:string:expectedFile}, ${2:string:actualString});","kind":"function","annotation":"assertStringEqualsFile(string $expectedFile, string $actualString): void","details":"assertStringEqualsFile(string $expectedFile, string $actualString): void"},
        {"trigger":"assertStringEqualsFileCanonicalizing","contents":"\\$this->assertStringEqualsFileCanonicalizing(${1:string:expectedFile}, ${2:string:actualString});","kind":"function","annotation":"assertStringEqualsFileCanonicalizing(string $expectedFile, string $actualString): void","details":"assertStringEqualsFileCanonicalizing(string $expectedFile, string $actualString): void"},
        {"trigger":"assertStringEqualsFileIgnoringCase","contents":"\\$this->assertStringEqualsFileIgnoringCase(${1:string:expectedFile}, ${2:string:actualString});","kind":"function","annotation":"assertStringEqualsFileIgnoringCase(string $expectedFile, string $actualString): void","details":"assertStringEqualsFileIgnoringCase(string $expectedFile, string $actualString): void"},
        {"trigger":"assertStringEqualsStringIgnoringLineEndings","contents":"\\$this->assertStringEqualsStringIgnoringLineEndings(${1:string:expected}, ${2:string:actual});","kind":"function","annotation":"assertStringEqualsStringIgnoringLineEndings(string $expected, string $actual): void","details":"assertStringEqualsStringIgnoringLineEndings(string $expected, string $actual): void"},
        {"trigger":"assertStringMatchesFormat","contents":"\\$this->assertStringMatchesFormat(${1:string:format}, ${2:string:string});","kind":"function","annotation":"assertStringMatchesFormat(string $format, string $string): void","details":"assertStringMatchesFormat(string $format, string $string): void"},
        {"trigger":"assertStringMatchesFormatFile","contents":"\\$this->assertStringMatchesFormatFile(${1:string:formatFile}, ${2:string:string});","kind":"function","annotation":"assertStringMatchesFormatFile(string $formatFile, string $string): void","details":"assertStringMatchesFormatFile(string $formatFile, string $string): void"},
        {"trigger":"assertStringNotContainsString","contents":"\\$this->assertStringNotContainsString(${1:string:needle}, ${2:string:haystack});","kind":"function","annotation":"assertStringNotContainsString(string $needle, string $haystack): void","details":"assertStringNotContainsString(string $needle, string $haystack): void"},
        {"trigger":"assertStringNotContainsStringIgnoringCase","contents":"\\$this->assertStringNotContainsStringIgnoringCase(${1:string:needle}, ${2:string:haystack});","kind":"function","annotation":"assertStringNotContainsStringIgnoringCase(string $needle, string $haystack): void","details":"assertStringNotContainsStringIgnoringCase(string $needle, string $haystack): void"},
        {"trigger":"assertStringNotEqualsFile","contents":"\\$this->assertStringNotEqualsFile(${1:string:expectedFile}, ${2:string:actualString});","kind":"function","annotation":"assertStringNotEqualsFile(string $expectedFile, string $actualString): void","details":"assertStringNotEqualsFile(string $expectedFile, string $actualString): void"},
        {"trigger":"assertStringNotEqualsFileCanonicalizing","contents":"\\$this->assertStringNotEqualsFileCanonicalizing(${1:string:expectedFile}, ${2:string:actualString});","kind":"function","annotation":"assertStringNotEqualsFileCanonicalizing(string $expectedFile, string $actualString): void","details":"assertStringNotEqualsFileCanonicalizing(string $expectedFile, string $actualString): void"},
        {"trigger":"assertStringNotEqualsFileIgnoringCase","contents":"\\$this->assertStringNotEqualsFileIgnoringCase(${1:string:expectedFile}, ${2:string:actualString});","kind":"function","annotation":"assertStringNotEqualsFileIgnoringCase(string $expectedFile, string $actualString): void","details":"assertStringNotEqualsFileIgnoringCase(string $expectedFile, string $actualString): void"},
        {"trigger":"assertStringNotMatchesFormat","contents":"\\$this->assertStringNotMatchesFormat(${1:string:format}, ${2:string:string});","kind":"function","annotation":"assertStringNotMatchesFormat(string $format, string $string): void","details":"assertStringNotMatchesFormat(string $format, string $string): void"},
        {"trigger":"assertStringNotMatchesFormatFile","contents":"\\$this->assertStringNotMatchesFormatFile(${1:string:formatFile}, ${2:string:string});","kind":"function","annotation":"assertStringNotMatchesFormatFile(string $formatFile, string $string): void","details":"assertStringNotMatchesFormatFile(string $formatFile, string $string): void"},
        {"trigger":"assertStringStartsNotWith","contents":"\\$this->assertStringStartsNotWith(${1:string:prefix}, ${2:string:string});","kind":"function","annotation":"assertStringStartsNotWith(string $prefix, string $string): void","details":"assertStringStartsNotWith(string $prefix, string $string): void"},
        {"trigger":"assertStringStartsWith","contents":"\\$this->assertStringStartsWith(${1:string:prefix}, ${2:string:string});","kind":"function","annotation":"assertStringStartsWith(string $prefix, string $string): void","details":"assertStringStartsWith(string $prefix, string $string): void"},
        {"trigger":"assertThat","contents":"\\$this->assertThat(${1:mixed:value}, ${2:PHPUnit\\Framework\\Constraint\\Constraint:constraint});","kind":"function","annotation":"assertThat(mixed $value, PHPUnit\\Framework\\Constraint\\Constraint $constraint): void","details":"assertThat(mixed $value, PHPUnit\\Framework\\Constraint\\Constraint $constraint): void"},
        {"trigger":"assertTrue","contents":"\\$this->assertTrue(${1:mixed:condition});","kind":"function","annotation":"assertTrue(mixed $condition): void","details":"assertTrue(mixed $condition): void"},
        {"trigger":"assertXmlFileEqualsXmlFile","contents":"\\$this->assertXmlFileEqualsXmlFile(${1:string:expectedFile}, ${2:string:actualFile});","kind":"function","annotation":"assertXmlFileEqualsXmlFile(string $expectedFile, string $actualFile): void","details":"assertXmlFileEqualsXmlFile(string $expectedFile, string $actualFile): void"},
        {"trigger":"assertXmlFileNotEqualsXmlFile","contents":"\\$this->assertXmlFileNotEqualsXmlFile(${1:string:expectedFile}, ${2:string:actualFile});","kind":"function","annotation":"assertXmlFileNotEqualsXmlFile(string $expectedFile, string $actualFile): void","details":"assertXmlFileNotEqualsXmlFile(string $expectedFile, string $actualFile): void"},
        {"trigger":"assertXmlStringEqualsXmlFile","contents":"\\$this->assertXmlStringEqualsXmlFile(${1:string:expectedFile}, ${2:string:actualXml});","kind":"function","annotation":"assertXmlStringEqualsXmlFile(string $expectedFile, string $actualXml): void","details":"assertXmlStringEqualsXmlFile(string $expectedFile, string $actualXml): void"},
        {"trigger":"assertXmlStringEqualsXmlString","contents":"\\$this->assertXmlStringEqualsXmlString(${1:string:expectedXml}, ${2:string:actualXml});","kind":"function","annotation":"assertXmlStringEqualsXmlString(string $expectedXml, string $actualXml): void","details":"assertXmlStringEqualsXmlString(string $expectedXml, string $actualXml): void"},
        {"trigger":"assertXmlStringNotEqualsXmlFile","contents":"\\$this->assertXmlStringNotEqualsXmlFile(${1:string:expectedFile}, ${2:string:actualXml});","kind":"function","annotation":"assertXmlStringNotEqualsXmlFile(string $expectedFile, string $actualXml): void","details":"assertXmlStringNotEqualsXmlFile(string $expectedFile, string $actualXml): void"},
        {"trigger":"assertXmlStringNotEqualsXmlString","contents":"\\$this->assertXmlStringNotEqualsXmlString(${1:string:expectedXml}, ${2:string:actualXml});","kind":"function","annotation":"assertXmlStringNotEqualsXmlString(string $expectedXml, string $actualXml): void","details":"assertXmlStringNotEqualsXmlString(string $expectedXml, string $actualXml): void"},
        {"trigger":"atLeast","contents":"\\$this->atLeast(${1:int:requiredInvocations});","kind":"function","annotation":"atLeast(int $requiredInvocations): PHPUnit\\Framework\\MockObject\\Rule\\InvokedAtLeastCount","details":"atLeast(int $requiredInvocations): PHPUnit\\Framework\\MockObject\\Rule\\InvokedAtLeastCount"},
        {"trigger":"atLeastOnce","contents":"\\$this->atLeastOnce();","kind":"function","annotation":"atLeastOnce(): PHPUnit\\Framework\\MockObject\\Rule\\InvokedAtLeastOnce","details":"atLeastOnce(): PHPUnit\\Framework\\MockObject\\Rule\\InvokedAtLeastOnce"},
        {"trigger":"atMost","contents":"\\$this->atMost(${1:int:allowedInvocations});","kind":"function","annotation":"atMost(int $allowedInvocations): PHPUnit\\Framework\\MockObject\\Rule\\InvokedAtMostCount","details":"atMost(int $allowedInvocations): PHPUnit\\Framework\\MockObject\\Rule\\InvokedAtMostCount"},
        {"trigger":"callback","contents":"\\$this->callback(${1:callable:callback});","kind":"function","annotation":"callback(callable $callback): PHPUnit\\Framework\\Constraint\\Callback","details":"callback(callable $callback): PHPUnit\\Framework\\Constraint\\Callback"},
        {"trigger":"containsEqual","contents":"\\$this->containsEqual(${1:mixed:value});","kind":"function","annotation":"containsEqual(mixed $value): PHPUnit\\Framework\\Constraint\\TraversableContainsEqual","details":"containsEqual(mixed $value): PHPUnit\\Framework\\Constraint\\TraversableContainsEqual"},
        {"trigger":"containsIdentical","contents":"\\$this->containsIdentical(${1:mixed:value});","kind":"function","annotation":"containsIdentical(mixed $value): PHPUnit\\Framework\\Constraint\\TraversableContainsIdentical","details":"containsIdentical(mixed $value): PHPUnit\\Framework\\Constraint\\TraversableContainsIdentical"},
        {"trigger":"containsOnly","contents":"\\$this->containsOnly(${1:string:type});","kind":"function","annotation":"containsOnly(string $type): PHPUnit\\Framework\\Constraint\\TraversableContainsOnly","details":"containsOnly(string $type): PHPUnit\\Framework\\Constraint\\TraversableContainsOnly"},
        {"trigger":"containsOnlyInstancesOf","contents":"\\$this->containsOnlyInstancesOf(${1:string:className});","kind":"function","annotation":"containsOnlyInstancesOf(string $className): PHPUnit\\Framework\\Constraint\\TraversableContainsOnly","details":"containsOnlyInstancesOf(string $className): PHPUnit\\Framework\\Constraint\\TraversableContainsOnly"},
        {"trigger":"countOf","contents":"\\$this->countOf(${1:int:count});","kind":"function","annotation":"countOf(int $count): PHPUnit\\Framework\\Constraint\\Count","details":"countOf(int $count): PHPUnit\\Framework\\Constraint\\Count"},
        {"trigger":"createConfiguredMock","contents":"\\$this->createConfiguredMock(${1:string:originalClassName}, ${2:array:configuration});","kind":"function","annotation":"createConfiguredMock(string $originalClassName, array $configuration): PHPUnit\\Framework\\MockObject\\MockObject","details":"createConfiguredMock(string $originalClassName, array $configuration): PHPUnit\\Framework\\MockObject\\MockObject"},
        {"trigger":"createConfiguredStub","contents":"\\$this->createConfiguredStub(${1:string:originalClassName}, ${2:array:configuration});","kind":"function","annotation":"createConfiguredStub(string $originalClassName, array $configuration): PHPUnit\\Framework\\MockObject\\Stub","details":"createConfiguredStub(string $originalClassName, array $configuration): PHPUnit\\Framework\\MockObject\\Stub"},
        {"trigger":"createMock","contents":"\\$this->createMock(${1:string:originalClassName});","kind":"function","annotation":"createMock(string $originalClassName): PHPUnit\\Framework\\MockObject\\MockObject","details":"createMock(string $originalClassName): PHPUnit\\Framework\\MockObject\\MockObject"},
        {"trigger":"createMockForIntersectionOfInterfaces","contents":"\\$this->createMockForIntersectionOfInterfaces(${1:array:interfaces});","kind":"function","annotation":"createMockForIntersectionOfInterfaces(array $interfaces): PHPUnit\\Framework\\MockObject\\MockObject","details":"createMockForIntersectionOfInterfaces(array $interfaces): PHPUnit\\Framework\\MockObject\\MockObject"},
        {"trigger":"createPartialMock","contents":"\\$this->createPartialMock(${1:string:originalClassName}, ${2:array:methods});","kind":"function","annotation":"createPartialMock(string $originalClassName, array $methods): PHPUnit\\Framework\\MockObject\\MockObject","details":"createPartialMock(string $originalClassName, array $methods): PHPUnit\\Framework\\MockObject\\MockObject"},
        {"trigger":"createStub","contents":"\\$this->createStub(${1:string:originalClassName});","kind":"function","annotation":"createStub(string $originalClassName): PHPUnit\\Framework\\MockObject\\Stub","details":"createStub(string $originalClassName): PHPUnit\\Framework\\MockObject\\Stub"},
        {"trigger":"createStubForIntersectionOfInterfaces","contents":"\\$this->createStubForIntersectionOfInterfaces(${1:array:interfaces});","kind":"function","annotation":"createStubForIntersectionOfInterfaces(array $interfaces): PHPUnit\\Framework\\MockObject\\Stub","details":"createStubForIntersectionOfInterfaces(array $interfaces): PHPUnit\\Framework\\MockObject\\Stub"},
        {"trigger":"createTestProxy","contents":"\\$this->createTestProxy(${1:string:originalClassName});","kind":"function","annotation":"createTestProxy(string $originalClassName): PHPUnit\\Framework\\MockObject\\MockObject","details":"createTestProxy(string $originalClassName): PHPUnit\\Framework\\MockObject\\MockObject"},
        {"trigger":"dataSetAsString","contents":"\\$this->dataSetAsString();","kind":"function","annotation":"dataSetAsString(): string","details":"dataSetAsString(): string"},
        {"trigger":"dataSetAsStringWithData","contents":"\\$this->dataSetAsStringWithData();","kind":"function","annotation":"dataSetAsStringWithData(): string","details":"dataSetAsStringWithData(): string"},
        {"trigger":"dependencyInput","contents":"\\$this->dependencyInput();","kind":"function","annotation":"dependencyInput(): array","details":"dependencyInput(): array"},
        {"trigger":"directoryExists","contents":"\\$this->directoryExists();","kind":"function","annotation":"directoryExists(): PHPUnit\\Framework\\Constraint\\DirectoryExists","details":"directoryExists(): PHPUnit\\Framework\\Constraint\\DirectoryExists"},
        {"trigger":"equalTo","contents":"\\$this->equalTo(${1:mixed:value});","kind":"function","annotation":"equalTo(mixed $value): PHPUnit\\Framework\\Constraint\\IsEqual","details":"equalTo(mixed $value): PHPUnit\\Framework\\Constraint\\IsEqual"},
        {"trigger":"equalToCanonicalizing","contents":"\\$this->equalToCanonicalizing(${1:mixed:value});","kind":"function","annotation":"equalToCanonicalizing(mixed $value): PHPUnit\\Framework\\Constraint\\IsEqualCanonicalizing","details":"equalToCanonicalizing(mixed $value): PHPUnit\\Framework\\Constraint\\IsEqualCanonicalizing"},
        {"trigger":"equalToIgnoringCase","contents":"\\$this->equalToIgnoringCase(${1:mixed:value});","kind":"function","annotation":"equalToIgnoringCase(mixed $value): PHPUnit\\Framework\\Constraint\\IsEqualIgnoringCase","details":"equalToIgnoringCase(mixed $value): PHPUnit\\Framework\\Constraint\\IsEqualIgnoringCase"},
        {"trigger":"equalToWithDelta","contents":"\\$this->equalToWithDelta(${1:mixed:value}, ${2:float:delta});","kind":"function","annotation":"equalToWithDelta(mixed $value, float $delta): PHPUnit\\Framework\\Constraint\\IsEqualWithDelta","details":"equalToWithDelta(mixed $value, float $delta): PHPUnit\\Framework\\Constraint\\IsEqualWithDelta"},
        {"trigger":"exactly","contents":"\\$this->exactly(${1:int:count});","kind":"function","annotation":"exactly(int $count): PHPUnit\\Framework\\MockObject\\Rule\\InvokedCount","details":"exactly(int $count): PHPUnit\\Framework\\MockObject\\Rule\\InvokedCount"},
        {"trigger":"expectException","contents":"\\$this->expectException(${1:string:exception});","kind":"function","annotation":"expectException(string $exception): void","details":"expectException(string $exception): void"},
        {"trigger":"expectExceptionCode","contents":"\\$this->expectExceptionCode(${1:string|int:code});","kind":"function","annotation":"expectExceptionCode(string|int $code): void","details":"expectExceptionCode(string|int $code): void"},
        {"trigger":"expectExceptionMessage","contents":"\\$this->expectExceptionMessage(${1:string:message});","kind":"function","annotation":"expectExceptionMessage(string $message): void","details":"expectExceptionMessage(string $message): void"},
        {"trigger":"expectExceptionMessageMatches","contents":"\\$this->expectExceptionMessageMatches(${1:string:regularExpression});","kind":"function","annotation":"expectExceptionMessageMatches(string $regularExpression): void","details":"expectExceptionMessageMatches(string $regularExpression): void"},
        {"trigger":"expectExceptionObject","contents":"\\$this->expectExceptionObject(${1:Exception:exception});","kind":"function","annotation":"expectExceptionObject(Exception $exception): void","details":"expectExceptionObject(Exception $exception): void"},
        {"trigger":"expectNotToPerformAssertions","contents":"\\$this->expectNotToPerformAssertions();","kind":"function","annotation":"expectNotToPerformAssertions(): void","details":"expectNotToPerformAssertions(): void"},
        {"trigger":"expectOutputRegex","contents":"\\$this->expectOutputRegex(${1:string:expectedRegex});","kind":"function","annotation":"expectOutputRegex(string $expectedRegex): void","details":"expectOutputRegex(string $expectedRegex): void"},
        {"trigger":"expectOutputString","contents":"\\$this->expectOutputString(${1:string:expectedString});","kind":"function","annotation":"expectOutputString(string $expectedString): void","details":"expectOutputString(string $expectedString): void"},
        {"trigger":"expectsOutput","contents":"\\$this->expectsOutput();","kind":"function","annotation":"expectsOutput(): bool","details":"expectsOutput(): bool"},
        {"trigger":"fail","contents":"\\$this->fail($1);","kind":"function","annotation":"fail($1): never","details":"fail($1): never"},
        {"trigger":"fileExists","contents":"\\$this->fileExists();","kind":"function","annotation":"fileExists(): PHPUnit\\Framework\\Constraint\\FileExists","details":"fileExists(): PHPUnit\\Framework\\Constraint\\FileExists"},
        {"trigger":"getMockBuilder","contents":"\\$this->getMockBuilder(${1:string:className});","kind":"function","annotation":"getMockBuilder(string $className): PHPUnit\\Framework\\MockObject\\MockBuilder","details":"getMockBuilder(string $className): PHPUnit\\Framework\\MockObject\\MockBuilder"},
        {"trigger":"getMockForAbstractClass","contents":"\\$this->getMockForAbstractClass(${1:string:originalClassName});","kind":"function","annotation":"getMockForAbstractClass(string $originalClassName): PHPUnit\\Framework\\MockObject\\MockObject","details":"getMockForAbstractClass(string $originalClassName): PHPUnit\\Framework\\MockObject\\MockObject"},
        {"trigger":"getMockForTrait","contents":"\\$this->getMockForTrait(${1:string:traitName});","kind":"function","annotation":"getMockForTrait(string $traitName): PHPUnit\\Framework\\MockObject\\MockObject","details":"getMockForTrait(string $traitName): PHPUnit\\Framework\\MockObject\\MockObject"},
        {"trigger":"getMockFromWsdl","contents":"\\$this->getMockFromWsdl(${1:string:wsdlFile});","kind":"function","annotation":"getMockFromWsdl(string $wsdlFile): PHPUnit\\Framework\\MockObject\\MockObject","details":"getMockFromWsdl(string $wsdlFile): PHPUnit\\Framework\\MockObject\\MockObject"},
        {"trigger":"greaterThan","contents":"\\$this->greaterThan(${1:mixed:value});","kind":"function","annotation":"greaterThan(mixed $value): PHPUnit\\Framework\\Constraint\\GreaterThan","details":"greaterThan(mixed $value): PHPUnit\\Framework\\Constraint\\GreaterThan"},
        {"trigger":"greaterThanOrEqual","contents":"\\$this->greaterThanOrEqual(${1:mixed:value});","kind":"function","annotation":"greaterThanOrEqual(mixed $value): PHPUnit\\Framework\\Constraint\\LogicalOr","details":"greaterThanOrEqual(mixed $value): PHPUnit\\Framework\\Constraint\\LogicalOr"},
        {"trigger":"groups","contents":"\\$this->groups();","kind":"function","annotation":"groups(): array","details":"groups(): array"},
        {"trigger":"hasDependencyInput","contents":"\\$this->hasDependencyInput();","kind":"function","annotation":"hasDependencyInput(): bool","details":"hasDependencyInput(): bool"},
        {"trigger":"hasUnexpectedOutput","contents":"\\$this->hasUnexpectedOutput();","kind":"function","annotation":"hasUnexpectedOutput(): bool","details":"hasUnexpectedOutput(): bool"},
        {"trigger":"identicalTo","contents":"\\$this->identicalTo(${1:mixed:value});","kind":"function","annotation":"identicalTo(mixed $value): PHPUnit\\Framework\\Constraint\\IsIdentical","details":"identicalTo(mixed $value): PHPUnit\\Framework\\Constraint\\IsIdentical"},
        {"trigger":"isEmpty","contents":"\\$this->isEmpty();","kind":"function","annotation":"isEmpty(): PHPUnit\\Framework\\Constraint\\IsEmpty","details":"isEmpty(): PHPUnit\\Framework\\Constraint\\IsEmpty"},
        {"trigger":"isFalse","contents":"\\$this->isFalse();","kind":"function","annotation":"isFalse(): PHPUnit\\Framework\\Constraint\\IsFalse","details":"isFalse(): PHPUnit\\Framework\\Constraint\\IsFalse"},
        {"trigger":"isFinite","contents":"\\$this->isFinite();","kind":"function","annotation":"isFinite(): PHPUnit\\Framework\\Constraint\\IsFinite","details":"isFinite(): PHPUnit\\Framework\\Constraint\\IsFinite"},
        {"trigger":"isInIsolation","contents":"\\$this->isInIsolation();","kind":"function","annotation":"isInIsolation(): bool","details":"isInIsolation(): bool"},
        {"trigger":"isInfinite","contents":"\\$this->isInfinite();","kind":"function","annotation":"isInfinite(): PHPUnit\\Framework\\Constraint\\IsInfinite","details":"isInfinite(): PHPUnit\\Framework\\Constraint\\IsInfinite"},
        {"trigger":"isInstanceOf","contents":"\\$this->isInstanceOf(${1:string:className});","kind":"function","annotation":"isInstanceOf(string $className): PHPUnit\\Framework\\Constraint\\IsInstanceOf","details":"isInstanceOf(string $className): PHPUnit\\Framework\\Constraint\\IsInstanceOf"},
        {"trigger":"isJson","contents":"\\$this->isJson();","kind":"function","annotation":"isJson(): PHPUnit\\Framework\\Constraint\\IsJson","details":"isJson(): PHPUnit\\Framework\\Constraint\\IsJson"},
        {"trigger":"isList","contents":"\\$this->isList();","kind":"function","annotation":"isList(): PHPUnit\\Framework\\Constraint\\IsList","details":"isList(): PHPUnit\\Framework\\Constraint\\IsList"},
        {"trigger":"isNan","contents":"\\$this->isNan();","kind":"function","annotation":"isNan(): PHPUnit\\Framework\\Constraint\\IsNan","details":"isNan(): PHPUnit\\Framework\\Constraint\\IsNan"},
        {"trigger":"isNull","contents":"\\$this->isNull();","kind":"function","annotation":"isNull(): PHPUnit\\Framework\\Constraint\\IsNull","details":"isNull(): PHPUnit\\Framework\\Constraint\\IsNull"},
        {"trigger":"isReadable","contents":"\\$this->isReadable();","kind":"function","annotation":"isReadable(): PHPUnit\\Framework\\Constraint\\IsReadable","details":"isReadable(): PHPUnit\\Framework\\Constraint\\IsReadable"},
        {"trigger":"isTrue","contents":"\\$this->isTrue();","kind":"function","annotation":"isTrue(): PHPUnit\\Framework\\Constraint\\IsTrue","details":"isTrue(): PHPUnit\\Framework\\Constraint\\IsTrue"},
        {"trigger":"isType","contents":"\\$this->isType(${1:string:type});","kind":"function","annotation":"isType(string $type): PHPUnit\\Framework\\Constraint\\IsType","details":"isType(string $type): PHPUnit\\Framework\\Constraint\\IsType"},
        {"trigger":"isWritable","contents":"\\$this->isWritable();","kind":"function","annotation":"isWritable(): PHPUnit\\Framework\\Constraint\\IsWritable","details":"isWritable(): PHPUnit\\Framework\\Constraint\\IsWritable"},
        {"trigger":"lessThan","contents":"\\$this->lessThan(${1:mixed:value});","kind":"function","annotation":"lessThan(mixed $value): PHPUnit\\Framework\\Constraint\\LessThan","details":"lessThan(mixed $value): PHPUnit\\Framework\\Constraint\\LessThan"},
        {"trigger":"lessThanOrEqual","contents":"\\$this->lessThanOrEqual(${1:mixed:value});","kind":"function","annotation":"lessThanOrEqual(mixed $value): PHPUnit\\Framework\\Constraint\\LogicalOr","details":"lessThanOrEqual(mixed $value): PHPUnit\\Framework\\Constraint\\LogicalOr"},
        {"trigger":"logicalAnd","contents":"\\$this->logicalAnd($1);","kind":"function","annotation":"logicalAnd($1): PHPUnit\\Framework\\Constraint\\LogicalAnd","details":"logicalAnd($1): PHPUnit\\Framework\\Constraint\\LogicalAnd"},
        {"trigger":"logicalNot","contents":"\\$this->logicalNot(${1:PHPUnit\\Framework\\Constraint\\Constraint:constraint});","kind":"function","annotation":"logicalNot(PHPUnit\\Framework\\Constraint\\Constraint $constraint): PHPUnit\\Framework\\Constraint\\LogicalNot","details":"logicalNot(PHPUnit\\Framework\\Constraint\\Constraint $constraint): PHPUnit\\Framework\\Constraint\\LogicalNot"},
        {"trigger":"logicalOr","contents":"\\$this->logicalOr($1);","kind":"function","annotation":"logicalOr($1): PHPUnit\\Framework\\Constraint\\LogicalOr","details":"logicalOr($1): PHPUnit\\Framework\\Constraint\\LogicalOr"},
        {"trigger":"logicalXor","contents":"\\$this->logicalXor($1);","kind":"function","annotation":"logicalXor($1): PHPUnit\\Framework\\Constraint\\LogicalXor","details":"logicalXor($1): PHPUnit\\Framework\\Constraint\\LogicalXor"},
        {"trigger":"markTestIncomplete","contents":"\\$this->markTestIncomplete($1);","kind":"function","annotation":"markTestIncomplete($1): never","details":"markTestIncomplete($1): never"},
        {"trigger":"markTestSkipped","contents":"\\$this->markTestSkipped($1);","kind":"function","annotation":"markTestSkipped($1): never","details":"markTestSkipped($1): never"},
        {"trigger":"matches","contents":"\\$this->matches(${1:string:string});","kind":"function","annotation":"matches(string $string): PHPUnit\\Framework\\Constraint\\StringMatchesFormatDescription","details":"matches(string $string): PHPUnit\\Framework\\Constraint\\StringMatchesFormatDescription"},
        {"trigger":"matchesRegularExpression","contents":"\\$this->matchesRegularExpression(${1:string:pattern});","kind":"function","annotation":"matchesRegularExpression(string $pattern): PHPUnit\\Framework\\Constraint\\RegularExpression","details":"matchesRegularExpression(string $pattern): PHPUnit\\Framework\\Constraint\\RegularExpression"},
        {"trigger":"name","contents":"\\$this->name();","kind":"function","annotation":"name(): string","details":"name(): string"},
        {"trigger":"nameWithDataSet","contents":"\\$this->nameWithDataSet();","kind":"function","annotation":"nameWithDataSet(): string","details":"nameWithDataSet(): string"},
        {"trigger":"never","contents":"\\$this->never();","kind":"function","annotation":"never(): PHPUnit\\Framework\\MockObject\\Rule\\InvokedCount","details":"never(): PHPUnit\\Framework\\MockObject\\Rule\\InvokedCount"},
        {"trigger":"numberOfAssertionsPerformed","contents":"\\$this->numberOfAssertionsPerformed();","kind":"function","annotation":"numberOfAssertionsPerformed(): int","details":"numberOfAssertionsPerformed(): int"},
        {"trigger":"onConsecutiveCalls","contents":"\\$this->onConsecutiveCalls($1);","kind":"function","annotation":"onConsecutiveCalls($1): PHPUnit\\Framework\\MockObject\\Stub\\ConsecutiveCalls","details":"onConsecutiveCalls($1): PHPUnit\\Framework\\MockObject\\Stub\\ConsecutiveCalls"},
        {"trigger":"once","contents":"\\$this->once();","kind":"function","annotation":"once(): PHPUnit\\Framework\\MockObject\\Rule\\InvokedCount","details":"once(): PHPUnit\\Framework\\MockObject\\Rule\\InvokedCount"},
        {"trigger":"output","contents":"\\$this->output();","kind":"function","annotation":"output(): string","details":"output(): string"},
        {"trigger":"providedData","contents":"\\$this->providedData();","kind":"function","annotation":"providedData(): array","details":"providedData(): array"},
        {"trigger":"registerFailureType","contents":"\\$this->registerFailureType(${1:string:classOrInterface});","kind":"function","annotation":"registerFailureType(string $classOrInterface): void","details":"registerFailureType(string $classOrInterface): void"},
        {"trigger":"registerMockObjectsFromTestArgumentsRecursively","contents":"\\$this->registerMockObjectsFromTestArgumentsRecursively();","kind":"function","annotation":"registerMockObjectsFromTestArgumentsRecursively(): void","details":"registerMockObjectsFromTestArgumentsRecursively(): void"},
        {"trigger":"result","contents":"\\$this->result();","kind":"function","annotation":"result(): mixed","details":"result(): mixed"},
        {"trigger":"returnArgument","contents":"\\$this->returnArgument(${1:int:argumentIndex});","kind":"function","annotation":"returnArgument(int $argumentIndex): PHPUnit\\Framework\\MockObject\\Stub\\ReturnArgument","details":"returnArgument(int $argumentIndex): PHPUnit\\Framework\\MockObject\\Stub\\ReturnArgument"},
        {"trigger":"returnCallback","contents":"\\$this->returnCallback(${1:callable:callback});","kind":"function","annotation":"returnCallback(callable $callback): PHPUnit\\Framework\\MockObject\\Stub\\ReturnCallback","details":"returnCallback(callable $callback): PHPUnit\\Framework\\MockObject\\Stub\\ReturnCallback"},
        {"trigger":"returnSelf","contents":"\\$this->returnSelf();","kind":"function","annotation":"returnSelf(): PHPUnit\\Framework\\MockObject\\Stub\\ReturnSelf","details":"returnSelf(): PHPUnit\\Framework\\MockObject\\Stub\\ReturnSelf"},
        {"trigger":"returnValue","contents":"\\$this->returnValue(${1:mixed:value});","kind":"function","annotation":"returnValue(mixed $value): PHPUnit\\Framework\\MockObject\\Stub\\ReturnStub","details":"returnValue(mixed $value): PHPUnit\\Framework\\MockObject\\Stub\\ReturnStub"},
        {"trigger":"returnValueMap","contents":"\\$this->returnValueMap(${1:array:valueMap});","kind":"function","annotation":"returnValueMap(array $valueMap): PHPUnit\\Framework\\MockObject\\Stub\\ReturnValueMap","details":"returnValueMap(array $valueMap): PHPUnit\\Framework\\MockObject\\Stub\\ReturnValueMap"},
        {"trigger":"setBackupGlobalsExcludeList","contents":"\\$this->setBackupGlobalsExcludeList(${1:array:backupGlobalsExcludeList});","kind":"function","annotation":"setBackupGlobalsExcludeList(array $backupGlobalsExcludeList): void","details":"setBackupGlobalsExcludeList(array $backupGlobalsExcludeList): void"},
        {"trigger":"setBackupStaticProperties","contents":"\\$this->setBackupStaticProperties(${1:bool:backupStaticProperties});","kind":"function","annotation":"setBackupStaticProperties(bool $backupStaticProperties): void","details":"setBackupStaticProperties(bool $backupStaticProperties): void"},
        {"trigger":"setBackupStaticPropertiesExcludeList","contents":"\\$this->setBackupStaticPropertiesExcludeList(${1:array:backupStaticPropertiesExcludeList});","kind":"function","annotation":"setBackupStaticPropertiesExcludeList(array $backupStaticPropertiesExcludeList): void","details":"setBackupStaticPropertiesExcludeList(array $backupStaticPropertiesExcludeList): void"},
        {"trigger":"setData","contents":"\\$this->setData(${1:string|int:dataName}, ${2:array:data});","kind":"function","annotation":"setData(string|int $dataName, array $data): void","details":"setData(string|int $dataName, array $data): void"},
        {"trigger":"size","contents":"\\$this->size();","kind":"function","annotation":"size(): PHPUnit\\Framework\\TestSize\\TestSize","details":"size(): PHPUnit\\Framework\\TestSize\\TestSize"},
        {"trigger":"status","contents":"\\$this->status();","kind":"function","annotation":"status(): PHPUnit\\Framework\\TestStatus\\TestStatus","details":"status(): PHPUnit\\Framework\\TestStatus\\TestStatus"},
        {"trigger":"stringContains","contents":"\\$this->stringContains(${1:string:string});","kind":"function","annotation":"stringContains(string $string): PHPUnit\\Framework\\Constraint\\StringContains","details":"stringContains(string $string): PHPUnit\\Framework\\Constraint\\StringContains"},
        {"trigger":"stringEndsWith","contents":"\\$this->stringEndsWith(${1:string:suffix});","kind":"function","annotation":"stringEndsWith(string $suffix): PHPUnit\\Framework\\Constraint\\StringEndsWith","details":"stringEndsWith(string $suffix): PHPUnit\\Framework\\Constraint\\StringEndsWith"},
        {"trigger":"stringEqualsStringIgnoringLineEndings","contents":"\\$this->stringEqualsStringIgnoringLineEndings(${1:string:string});","kind":"function","annotation":"stringEqualsStringIgnoringLineEndings(string $string): PHPUnit\\Framework\\Constraint\\StringEqualsStringIgnoringLineEndings","details":"stringEqualsStringIgnoringLineEndings(string $string): PHPUnit\\Framework\\Constraint\\StringEqualsStringIgnoringLineEndings"},
        {"trigger":"stringStartsWith","contents":"\\$this->stringStartsWith(${1:string:prefix});","kind":"function","annotation":"stringStartsWith(string $prefix): PHPUnit\\Framework\\Constraint\\StringStartsWith","details":"stringStartsWith(string $prefix): PHPUnit\\Framework\\Constraint\\StringStartsWith"},
        {"trigger":"throwException","contents":"\\$this->throwException(${1:Throwable:exception});","kind":"function","annotation":"throwException(Throwable $exception): PHPUnit\\Framework\\MockObject\\Stub\\Exception","details":"throwException(Throwable $exception): PHPUnit\\Framework\\MockObject\\Stub\\Exception"},
        {"trigger":"transformException","contents":"\\$this->transformException(${1:Throwable:t});","kind":"function","annotation":"transformException(Throwable $t): Throwable","details":"transformException(Throwable $t): Throwable"},
        {"trigger":"valueObjectForEvents","contents":"\\$this->valueObjectForEvents();","kind":"function","annotation":"valueObjectForEvents(): PHPUnit\\Event\\Code\\TestMethod","details":"valueObjectForEvents(): PHPUnit\\Event\\Code\\TestMethod"},
        {"trigger":"wasPrepared","contents":"\\$this->wasPrepared();","kind":"function","annotation":"wasPrepared(): bool","details":"wasPrepared(): bool"}
    ]
}
